<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>0106 - Further topics · SPMLJ</title><meta name="title" content="0106 - Further topics · SPMLJ"/><meta property="og:title" content="0106 - Further topics · SPMLJ"/><meta property="twitter:title" content="0106 - Further topics · SPMLJ"/><meta name="description" content="Documentation for SPMLJ."/><meta property="og:description" content="Documentation for SPMLJ."/><meta property="twitter:description" content="Documentation for SPMLJ."/><script async src="https://www.googletagmanager.com/gtag/js?id=G-Q39LHCRBB6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-Q39LHCRBB6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">SPMLJ</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Index</a></li><li><span class="tocitem">Lessons</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">INTRO - Introduction to the course, Julia and ML</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../00_-_INTRO_-_Introduction_julia_ml/0001_-_Course_presentation.html">0001 - Course presentation</a></li><li><a class="tocitem" href="../00_-_INTRO_-_Introduction_julia_ml/0002_-_Program.html">0002 - Program</a></li><li><a class="tocitem" href="../00_-_INTRO_-_Introduction_julia_ml/0003_-_Introduction_to_Julia.html">0003 - Introduction to Julia</a></li><li><a class="tocitem" href="../00_-_INTRO_-_Introduction_julia_ml/0003q_-_QUIZ_0.1.html">0003q - QUIZ 0.1</a></li><li><a class="tocitem" href="../00_-_INTRO_-_Introduction_julia_ml/0004_-_Introduction_to_ML.html">0004 - Introduction to ML</a></li><li><a class="tocitem" href="../00_-_INTRO_-_Introduction_julia_ml/0004q_-_QUIZ_0.2.html">0004q - QUIZ 0.2</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">JULIA1 - Basic Julia programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="0101_-_Basic_syntax.html">0101 - Basic syntax</a></li><li><a class="tocitem" href="0101q_-_QUIZ_1.1.html">0101q - QUIZ 1.1</a></li><li><a class="tocitem" href="0101q_-_QUIZ_1.2.html">0101q - QUIZ 1.2</a></li><li><a class="tocitem" href="0102_-_Types_and_objects.html">0102 - Types and objects</a></li><li><a class="tocitem" href="0102q_-_QUIZ_1.3.html">0102q - QUIZ 1.3</a></li><li><a class="tocitem" href="0103_-_Predefined_types.html">0103 - Predefined types</a></li><li><a class="tocitem" href="0103q_-_QUIZ_1.4.html">0103q - QUIZ 1.4</a></li><li><a class="tocitem" href="0103q_-_QUIZ_1.5.html">0103q - QUIZ 1.5</a></li><li><a class="tocitem" href="0103q_-_QUIZ_1.6.html">0103q - QUIZ 1.6</a></li><li><a class="tocitem" href="0104_-_Control_flow_and_functions.html">0104 - Control flow and functions</a></li><li><a class="tocitem" href="0104q_-_QUIZ_1.7.html">0104q - QUIZ 1.7</a></li><li><a class="tocitem" href="0104q_-_QUIZ_1.8.html">0104q - QUIZ 1.8</a></li><li><a class="tocitem" href="0105_-_Custom_types.html">0105 - Custom types</a></li><li><a class="tocitem" href="0105q_-_QUIZ_1.10.html">0105q - QUIZ 1.10</a></li><li><a class="tocitem" href="0105q_-_QUIZ_1.9.html">0105q - QUIZ 1.9</a></li><li><a class="tocitem" href="0105x_EXERCISE-1.1.html">0105x EXERCISE-1.1</a></li><li class="is-active"><a class="tocitem" href="0106_-_Further_topics.html">0106 - Further topics</a><ul class="internal"><li><a class="tocitem" href="#Some-stuff-to-set-up-the-environment.."><span>Some stuff to set-up the environment..</span></a></li><li><a class="tocitem" href="#Metaprogramming-and-macros"><span>Metaprogramming and macros</span></a></li><li><a class="tocitem" href="#Interfacing-with-other-languages"><span>Interfacing with other languages</span></a></li><li><a class="tocitem" href="#Some-performance-tips"><span>Some performance tips</span></a></li><li><a class="tocitem" href="#Profiling-the-code-to-discover-bootlenecks"><span>Profiling the code to discover bootlenecks</span></a></li><li><a class="tocitem" href="#Introspection-and-debugging"><span>Introspection and debugging</span></a></li><li><a class="tocitem" href="#Runtime-exceptions"><span>Runtime exceptions</span></a></li><li><a class="tocitem" href="#parallel_computation"><span>Parallel computation</span></a></li></ul></li><li><a class="tocitem" href="0106q_-_QUIZ_1.11.html">0106q - QUIZ 1.11</a></li><li><a class="tocitem" href="0106q_-_QUIZ_1.12.html">0106q - QUIZ 1.12</a></li><li><a class="tocitem" href="0106q_-_QUIZ_1.13.html">0106q - QUIZ 1.13</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">JULIA2 - Scientific programming with Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../02_-_JULIA2_-_Scientific_programming_with_Julia/0201_-_Wranging_data.html">0201 - Wranging data</a></li><li><a class="tocitem" href="../02_-_JULIA2_-_Scientific_programming_with_Julia/0202_-_Miscellaneous_topics.html">0202 - Miscellaneous topics</a></li><li><a class="tocitem" href="../02_-_JULIA2_-_Scientific_programming_with_Julia/0202x_EXERCISE-2.1.html">0202x EXERCISE-2.1</a></li><li><a class="tocitem" href="../02_-_JULIA2_-_Scientific_programming_with_Julia/0202x_EXERCISE-2.2.html">0202x EXERCISE-2.2</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">ML1 - Introduction to Machine Learning</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../03_-_ML1_-_Introduction_to_Machine_Learning/0301_-_Machine_learning_main_concepts.html">0301 - Machine learning main concepts</a></li><li><a class="tocitem" href="../03_-_ML1_-_Introduction_to_Machine_Learning/0302_-_The_Perceptron_classifier.html">0302 - The Perceptron classifier</a></li><li><a class="tocitem" href="../03_-_ML1_-_Introduction_to_Machine_Learning/0302x_EXERCISE-3.1.html">0302x EXERCISE-3.1</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">NN - Neural Networks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../04_-_NN_-_Neural_Networks/0401_-_Neural_network_architectures.html">0401 - Neural network architectures</a></li><li><a class="tocitem" href="../04_-_NN_-_Neural_Networks/0402_-_Implementation_of_neural_networks_workflows.html">0402 - Implementation of neural networks workflows</a></li><li><a class="tocitem" href="../04_-_NN_-_Neural_Networks/0402x_EXERCISE-4.1.html">0402x EXERCISE-4.1</a></li><li><a class="tocitem" href="../04_-_NN_-_Neural_Networks/0402x_EXERCISE-4.2.html">0402x EXERCISE-4.2</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">DT - Decision trees based algorithms [DRAFT]</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../05_-_DT_-_Decision_trees_based_algorithms/0501_-_Decision_trees_based_algorithms.html">0501 - Decision trees based algorithms</a></li><li><a class="tocitem" href="../05_-_DT_-_Decision_trees_based_algorithms/0502x_EXERCISE-5.1.html">0502x EXERCISE-5.1</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Lessons</a></li><li><a class="is-disabled">JULIA1 - Basic Julia programming</a></li><li class="is-active"><a href="0106_-_Further_topics.html">0106 - Further topics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="0106_-_Further_topics.html">0106 - Further topics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sylvaticus/SPMLJ" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sylvaticus/SPMLJ/blob/main/lessonsSources/01_-_JULIA1_-_Basic_Julia_programming/0106_-_Further_topics.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><div id="ytb-videos">
<span style=font-weight:bold;>Videos related to this segment (click the title to watch)</span>
<details open><summary>01 JULIA1  - 6A: Metaprogramming and macros (23:46)</summary>
<div class="container ytb-container">
    <div class="embed-responsive embed-responsive-16by9">
        <iframe class="embed-responsive-item" src="https://www.youtube.com/embed/Q3Fx6pFLCFk" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" frameborder="0"></iframe>
    </div>
</div>
</details>
<details ><summary>01 JULIA1  - 6B: Interoperability with other languages (23:6)</summary>
<div class="container ytb-container">
    <div class="embed-responsive embed-responsive-16by9">
        <iframe class="embed-responsive-item" src="https://www.youtube.com/embed/xK_Ug2gtQvU" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" frameborder="0"></iframe>
    </div>
</div>
</details>
<details ><summary>01 JULIA1  - 6C: Performances and errors:  profiling, debugging, introspection and exceptions (27:33)</summary>
<div class="container ytb-container">
    <div class="embed-responsive embed-responsive-16by9">
        <iframe class="embed-responsive-item" src="https://www.youtube.com/embed/vg8v_6oX2DM" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" frameborder="0"></iframe>
    </div>
</div>
</details>
<details ><summary>01 JULIA1  - 6D: Parallel computation:  multithreading, multiprocessing (20:3)</summary>
<div class="container ytb-container">
    <div class="embed-responsive embed-responsive-16by9">
        <iframe class="embed-responsive-item" src="https://www.youtube.com/embed/L849oXXCXFM" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" frameborder="0"></iframe>
    </div>
</div>
</details>
</div><hr/><h1 id="0106-Further-Topics"><a class="docs-heading-anchor" href="#0106-Further-Topics">0106 Further Topics</a><a id="0106-Further-Topics-1"></a><a class="docs-heading-anchor-permalink" href="#0106-Further-Topics" title="Permalink"></a></h1><h2 id="Some-stuff-to-set-up-the-environment.."><a class="docs-heading-anchor" href="#Some-stuff-to-set-up-the-environment..">Some stuff to set-up the environment..</a><a id="Some-stuff-to-set-up-the-environment..-1"></a><a class="docs-heading-anchor-permalink" href="#Some-stuff-to-set-up-the-environment.." title="Permalink"></a></h2><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; cd(@__DIR__)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Pkg</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Pkg.activate(&quot;.&quot;)
       # If using a Julia version different than 1.10 please uncomment and run the following line (reproductibility guarantee will however be lost)
       # Pkg.resolve()
       # Pkg.instantiate() # run this if you didn&#39;t in Segment 01.01</code><code class="nohighlight hljs ansi" style="display:block;">  Activating project at `~/work/SPMLJ/SPMLJ/buildedDoc/01_-_JULIA1_-_Basic_Julia_programming`</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Random</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Random.seed!(123)</code><code class="nohighlight hljs ansi" style="display:block;">Random.TaskLocalRNG()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using InteractiveUtils # loaded automatically when working... interactively</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h2 id="Metaprogramming-and-macros"><a class="docs-heading-anchor" href="#Metaprogramming-and-macros">Metaprogramming and macros</a><a id="Metaprogramming-and-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Metaprogramming-and-macros" title="Permalink"></a></h2><p>&quot;running&quot; some code include the following passages (roughly):</p><ul><li>parsing of the text defining the code and its translation in hierarchical expressions to the Abstract syntax Tree (AST) (syntax errors are caugth at this time)</li><li>on the first instance required (&quot;just in time&quot;) compilation of the AST expressions into object code (using the LLVM compiler)</li><li>execution of the compiled object code</li></ul><p>&quot;Macros&quot; in many other language (e.g. C or C++) refer to the possibility to &quot;pre-process&quot; the textual representation of the code statements before it is parsed. In julia instead it refers to the possibility to alter the expression once has already being parsed in the AST, allowing a greater expressivity as we are no longer limited by the parsing syntax</p><p>The AST is organised in a hierarchical tree of <em>expressions</em> where each element (including the operators) is a <em>symbol</em> For variables, you can use symbols to refer to the actual identifiers instad to the variable&#39;s value</p><p>Expressions themselves are objects representing unevaluated computer expressions</p><h3 id="Expressions-and-symbols"><a class="docs-heading-anchor" href="#Expressions-and-symbols">Expressions and symbols</a><a id="Expressions-and-symbols-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions-and-symbols" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr1 = Meta.parse(&quot;a = b + 2&quot;) # What the parser do when reading the source code. b doesn&#39;t need to actually been defined, it&#39;s just a namebinding without the reference to any object, not even `nothing`</code><code class="nohighlight hljs ansi" style="display:block;">:(a = b + 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(expr1) # expressions are first class objects</code><code class="nohighlight hljs ansi" style="display:block;">Expr</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr2 = :(a = b + 1)</code><code class="nohighlight hljs ansi" style="display:block;">:(a = b + 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr3 = quote a = b + 1 end</code><code class="nohighlight hljs ansi" style="display:block;">quote
    <span class="sgr90">#= REPL[4]:1 =#</span>
    a = b + 1
end</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr3</code><code class="nohighlight hljs ansi" style="display:block;">quote
    <span class="sgr90">#= REPL[4]:1 =#</span>
    a = b + 1
end</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dump(expr1)   # The AST ! Note this is already a nested statement, an assignment of the result of an expression (the sum call between the symbol `:b` and 1) to the symbol `a`</code><code class="nohighlight hljs ansi" style="display:block;">Expr
  head: Symbol =
  args: Array{Any}((2,))
    1: Symbol a
    2: Expr
      head: Symbol call
      args: Array{Any}((3,))
        1: Symbol +
        2: Symbol b
        3: Int64 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr4 = Expr(:(=),:a,Expr(:call,:+,:b,1)) # The AST using the &quot;Expr&quot; constructor</code><code class="nohighlight hljs ansi" style="display:block;">:(a = b + 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; symbol1   = :(a)               # as for expressions</code><code class="nohighlight hljs ansi" style="display:block;">:a</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; symbol2   = Meta.parse(&quot;a&quot;)    # as for expressions</code><code class="nohighlight hljs ansi" style="display:block;">:a</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; symbol3   = Symbol(&quot;a&quot;)        # specific for symbols only</code><code class="nohighlight hljs ansi" style="display:block;">:a</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; othsymbol = Symbol(&quot;aaa&quot;,10,&quot;bbb&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">:aaa10bbb</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(symbol1)</code><code class="nohighlight hljs ansi" style="display:block;">Symbol</code></pre><p>I can access any parts of my expression before evaluating it (indeed, that&#39;s what macro will do...)</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; myASymbol = expr1.args[2].args[1]</code><code class="nohighlight hljs ansi" style="display:block;">:+</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr1.args[2].args[1] = :(*)</code><code class="nohighlight hljs ansi" style="display:block;">:*</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = 2
       # a # error, a not defined</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eval(expr1)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a # here now is defined and it has an object associated... 4!</code><code class="nohighlight hljs ansi" style="display:block;">4</code></pre><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>The capability to evaluate expressions is very powerfull but due to obvious secutiry implications never evaluate expressions you aren&#39;t sure of their provenience. For example if you develop a Julia web app (e.g. using <a href="https://github.com/GenieFramework/Genie.jl">Genie.jl</a>) never evaluate user provided expressions.</p></div></div><p>Note that evaluation of expressions happens always at global scope, even if it done inside a function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function foo()
           locVar = 1
           expr = :(locVar + 1)
           return eval(expr)
       end
       # a = foo() # error locVar not defined</code><code class="nohighlight hljs ansi" style="display:block;">foo (generic function with 1 method)</code></pre><p>To refer to the <em>value</em> of a variable rather than the identifier itself within an expression, interpolate the variable using the dollar sign:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = :($a + b) # here the identifier &#39;a&#39; has been replaced with its numerical value, `4`</code><code class="nohighlight hljs ansi" style="display:block;">:(4 + b)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dump(expr)</code><code class="nohighlight hljs ansi" style="display:block;">Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 4
    3: Symbol b</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eval(expr)</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 10</code><code class="nohighlight hljs ansi" style="display:block;">10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eval(expr) # no changes</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = 100</code><code class="nohighlight hljs ansi" style="display:block;">100</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eval(expr) # here it change, as it is at eval time that the identifier `b` is &quot;replaced&quot; with its value</code><code class="nohighlight hljs ansi" style="display:block;">104</code></pre><h3 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h3><p>One of the best usage of macros is they allow package developers to provide a very flexible API to their package, suited for the specific needs of the package, making life easier for the users. Compare for example <a href="https://jump.dev/JuMP.jl/stable/manual/constraints/">the API of JuMP</a> with <a href="https://pyomo.readthedocs.io/en/stable/pyomo_modeling_components/Constraints.html">those of Pyomo</a> to define model constraints !</p><p>Some examples of macros: <a href="https://github.com/sylvaticus/MultiDimEquations.jl">MultiDimEquations.jl</a></p><ul><li>from: <code>@meq par1[d1 in DIM1, d2 in DIM2, dfix3] =  par2[d1,d2]+par3[d1,d2]</code></li><li>to:   <code>[par1[d1,d2,dfix3] =  par2[d1,d2]+par3[d1,d2] for d1 in DIM1, d2 in DIM2]</code></li></ul><p><a href="https://github.com/oxinabox/Pipe.jl">Pipe.jl:</a></p><ul><li>from: <code>@pipe  10 |&gt; foo(_,a) |&gt; foo2(b,_,c) |&gt; foo3(_)</code></li><li>to:   <code>foo3(foo2(b,foo(10,a),c))</code></li></ul><p>Brodcasting (Base):</p><ul><li>from: <code>@. a + b * D^2</code></li><li>to:   <code>a .+ b .* D.^2</code></li></ul><p>Defining a macro...</p><p>Like functions, but both the arguments and the returned output are expressions</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; macro customLoop(controlExpr,workExpr)
           return quote
             for i in $controlExpr
               $workExpr
             end
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">@customLoop (macro with 1 method)</code></pre><p>Invoking a macro....</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 5</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @customLoop 1:4 println(i) #note that &quot;i&quot; is in the macro</code><code class="nohighlight hljs ansi" style="display:block;">1
2
3
4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @customLoop 1:a println(i)</code><code class="nohighlight hljs ansi" style="display:block;">1
2
3
4
5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @customLoop 1:a if i &gt; 3 println(i) end</code><code class="nohighlight hljs ansi" style="display:block;">4
5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @customLoop [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]  println(i)</code><code class="nohighlight hljs ansi" style="display:block;">apple
orange
banana</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @customLoop [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]  begin print(&quot;i: &quot;); println(i)  end</code><code class="nohighlight hljs ansi" style="display:block;">i: apple
i: orange
i: banana</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @macroexpand @customLoop 1:4 println(i) # print what the macro does with the specific expressions provided</code><code class="nohighlight hljs ansi" style="display:block;">quote
    <span class="sgr90">#= REPL[1]:3 =#</span>
    for var&quot;#433#i&quot; = 1:4
        <span class="sgr90">#= REPL[1]:4 =#</span>
        Main.var&quot;Main&quot;.println(var&quot;#433#i&quot;)
        <span class="sgr90">#= REPL[1]:5 =#</span>
    end
end</code></pre><p>String macros (aka &quot;non-standard string literals&quot;) Invoked with the syntax <code>xxx&quot; ...text...&quot;</code> or <code>xxx&quot;&quot;&quot; ...multi-line text...&quot;&quot;&quot;</code> where <code>xxx</code> is the name of the macro and the macro must be defined as <code>macro  xxx_str</code>. Used to perform textual modification o nthe given text, for example this print the given text on a 8 characters</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; macro print8_str(mystr)                                 # input here is a string, not an expression
           limits = collect(1:8:length(mystr))
           for (i,j) in enumerate(limits)
             st = j
             en = i==length(limits) ? length(mystr) : j+7
             println(mystr[st:en])
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">@print8_str (macro with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print8&quot;123456789012345678&quot;</code><code class="nohighlight hljs ansi" style="display:block;">12345678
90123456
78</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print8&quot;&quot;&quot;This is a text that once printed in 8 columns with terminal will be several lines. Ok, no rammar rules relating to carriage returns are emploied here...&quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">This is 
a text t
hat once
 printed
 in 8 co
lumns wi
th termi
nal will
 be seve
ral line
s. Ok, n
o rammar
 rules r
elating 
to carri
age retu
rns are 
emploied
 here...</code></pre><p>While normally used to modify text, string macros are &quot;true&quot; macros:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; macro customLoop_str(str)
           exprs = Meta.parse(str)
           controlExpr,workExpr = exprs.args[1],exprs.args[2]
           return quote
             for i in $controlExpr
               $workExpr
             end
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">@customLoop_str (macro with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; customLoop&quot;&quot;&quot;1:4; println(i)&quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">1
2
3
4</code></pre><h2 id="Interfacing-with-other-languages"><a class="docs-heading-anchor" href="#Interfacing-with-other-languages">Interfacing with other languages</a><a id="Interfacing-with-other-languages-1"></a><a class="docs-heading-anchor-permalink" href="#Interfacing-with-other-languages" title="Permalink"></a></h2><p>There are 3 ways to interface Julia with programs or libraries wrote in other languages. At the lowest level, Julia allows to directly interface with C or Fortran libraries, and this means, aside using directly libraries written in C, to be able to interface with any programming language that offer also a C interface (R, Python...) Using this low level C Interface, users have created specific packages to interface many languages using a simple, Julian-way syntax. We will see these interfaces for R and Python. Finally, at the highest level, many common packages of other languages have been already &quot;interfaced&quot;, so that the user can use the Julia Package without even knowing that this is an interface for an other package, for example <code>SymPy.jl</code> is a large interface to the Python package <code>SymPy</code>.</p><h3 id="Using-C-libraries"><a class="docs-heading-anchor" href="#Using-C-libraries">Using C libraries</a><a id="Using-C-libraries-1"></a><a class="docs-heading-anchor-permalink" href="#Using-C-libraries" title="Permalink"></a></h3><p>Let&#39;s start by seing how to use a C library. For this example to work you will need to have the GCC compiler installed on your machine First let&#39;s write the header and source C files and write them to the disk:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; cheader = &quot;&quot;&quot;
       extern int get5();
       extern double mySum(float x, float y);
       &quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;extern int get5();\nextern double mySum(float x, float y);\n&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; csource = &quot;&quot;&quot;
       int get5(){
           return 5;
       }
       
       double mySum(float x, float y){
           return x+y;
       }
       &quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;int get5(){\n    return 5;\n}\n\ndouble mySum(float x, float y){\n    return x+y;\n}\n&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; open(f-&gt;write(f,cheader),&quot;myclib.h&quot;,&quot;w&quot;)  # We open a stream to file with the &quot;w&quot; parameter as for &quot;writing&quot;, and we pass the stream to the anonymous function to actually write to the stream. If this funcitons is many lines of code, consider rewriting the `open` statement using a `do` block</code><code class="nohighlight hljs ansi" style="display:block;">58</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; open(f-&gt;write(f,csource),&quot;myclib.c&quot;,&quot;w&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">79</code></pre><p>Now let&#39;s run the command to compile the C code we saved as shared library using gcc, a C compiler. The following example assume that GCC is installed in the machine where this example is run and available as <code>gcc</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; compilationCommand1 = `gcc -o myclib.o -c myclib.c` # the actual compilation, note the backticks used to define a command</code><code class="nohighlight hljs ansi" style="display:block;">`<span class="sgr4">gcc</span> <span class="sgr4">-o</span> <span class="sgr4">myclib.o</span> <span class="sgr4">-c</span> <span class="sgr4">myclib.c</span>`</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; compilationCommand2 = `gcc -shared -o libmyclib.so myclib.o -lm -fPIC` # the linking into a shared library</code><code class="nohighlight hljs ansi" style="display:block;">`<span class="sgr4">gcc</span> <span class="sgr4">-shared</span> <span class="sgr4">-o</span> <span class="sgr4">libmyclib.so</span> <span class="sgr4">myclib.o</span> <span class="sgr4">-lm</span> <span class="sgr4">-fPIC</span>`</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; run(compilationCommand1)</code><code class="nohighlight hljs ansi" style="display:block;">Process(`<span class="sgr4">gcc</span> <span class="sgr4">-o</span> <span class="sgr4">myclib.o</span> <span class="sgr4">-c</span> <span class="sgr4">myclib.c</span>`, ProcessExited(0))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; run(compilationCommand2)</code><code class="nohighlight hljs ansi" style="display:block;">Process(`<span class="sgr4">gcc</span> <span class="sgr4">-shared</span> <span class="sgr4">-o</span> <span class="sgr4">libmyclib.so</span> <span class="sgr4">myclib.o</span> <span class="sgr4">-lm</span> <span class="sgr4">-fPIC</span>`, ProcessExited(0))</code></pre><p>This should have created the C library <code>libmyclib.so</code> on disk. Let&#39;s gonna use it:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const myclib = joinpath(@__DIR__, &quot;libmyclib.so&quot;)  # we need the full path</code><code class="nohighlight hljs ansi" style="display:block;">&quot;/home/runner/work/SPMLJ/SPMLJ/buildedDoc/01_-_JULIA1_-_Basic_Julia_programming/libmyclib.so&quot;</code></pre><p>ccall arguments:</p><ol><li>A tuple with the funcion name to call and the library path. For both, if embedded in a variable, the variable must be set constant.</li><li>The Julia type that map to the C type returned by the function.<ul><li><code>int</code> → <code>Int32</code> or <code>Int64</code> (or the easy-to remmeber <code>Cint</code> alias)</li><li><code>float</code> → <code>Float32</code> (or the <code>Cfloat</code> alias)</li><li><code>double</code> → <code>Float64</code> (or the <code>Cdouble</code> alias)</li></ul></li><li>A tuple with the Julia types of the parameters passed to the C function</li><li>Any other argument are the values of the parameter passed</li></ol><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = ccall((:get5,myclib), Int32, ())</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = ccall((:mySum,myclib), Float64, (Float32,Float32), 2.5, 1.5)</code><code class="nohighlight hljs ansi" style="display:block;">4.0</code></pre><p>More details on calling C or Fortran code can be obtained <a href="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/">in the official Julia documentation</a>.</p><h3 id="Using-Python-in-Julia"><a class="docs-heading-anchor" href="#Using-Python-in-Julia">Using Python in Julia</a><a id="Using-Python-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Python-in-Julia" title="Permalink"></a></h3><p>The &quot;default&quot; way to use Python code in Julia is trough the <a href="https://github.com/JuliaPy/PyCall.jl">PyCall.jl</a> package. It automatically take care of convert between Python types (including numpy arrays) and Julia types (types that can not be converted automatically are converted to the generic <code>PyObject</code> type).</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ENV[&quot;PYTHON&quot;] = &quot;&quot; # will force PyCall to download and use a &quot;private to Julia&quot; (conda based) version of Python. use &quot;/path/to/python&quot; if you want to reuse a version already installed on your system
       
       # using Pkg
       # Pkg.add(&quot;PyCall&quot;)
       # Pkg.build(&quot;PyCall&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using PyCall</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h4 id="Embed-short-python-snippets-in-Julia"><a class="docs-heading-anchor" href="#Embed-short-python-snippets-in-Julia">Embed short python snippets in Julia</a><a id="Embed-short-python-snippets-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Embed-short-python-snippets-in-Julia" title="Permalink"></a></h4><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; py&quot;&quot;&quot;
       def sumMyArgs (i, j):
         return i+j
       def getNthElement (vec,n):
         return vec[n]
       &quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = py&quot;sumMyArgs&quot;(3,4)             # 7 - here we call the Python object (a function) with Julia parameters</code><code class="nohighlight hljs ansi" style="display:block;">7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = py&quot;getNthElement&quot;([1,2,3],1)   # 2 - attention to the diffferent convention for starting arrays!. Note the Julia Array ahas been converted automatically to a Python list</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = py&quot;getNthElement([1,$a,3],1)&quot;  # 7 - here we interpolate the Python call</code><code class="nohighlight hljs ansi" style="display:block;">7</code></pre><p>Alternativly, use <code>@pyinclude(&quot;pythonScript.py&quot;)</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pythonCode = &quot;&quot;&quot;
       def sumMyArgs (i, j, z):
         return i+j+z
       &quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;def sumMyArgs (i, j, z):\n  return i+j+z\n&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; open(f-&gt;write(f,pythonCode),&quot;pythonScript.py&quot;,&quot;w&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">40</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @pyinclude(&quot;pythonScript.py&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = py&quot;sumMyArgs&quot;(3,4,5)</code><code class="nohighlight hljs ansi" style="display:block;">12</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Note thaat the 3 arguments definition of <code>sumMyArgs</code> has <em>replaced</em> the 3-arguments one. This would now error <code>py&quot;sumMyArgs&quot;(3,4)</code></p></div></div><h4 id="Use-Python-libraries"><a class="docs-heading-anchor" href="#Use-Python-libraries">Use Python libraries</a><a id="Use-Python-libraries-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Python-libraries" title="Permalink"></a></h4><p>Add a package to the local Python installation using Conda:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pyimport_conda(&quot;ezodf&quot;, &quot;ezodf&quot;, &quot;conda-forge&quot;) # pyimport_conda(module, package, channel)</code><code class="nohighlight hljs ansi" style="display:block;">PyObject &lt;module &#39;ezodf&#39; from &#39;/home/runner/.local/lib/python3.10/site-packages/ezodf/__init__.py&#39;&gt;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; const ez = pyimport(&quot;ezodf&quot;)  # Equiv. of Python `import ezodf as ez`</code><code class="nohighlight hljs ansi" style="display:block;">PyObject &lt;module &#39;ezodf&#39; from &#39;/home/runner/.local/lib/python3.10/site-packages/ezodf/__init__.py&#39;&gt;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; destDoc  = ez.newdoc(doctype=&quot;ods&quot;, filename=&quot;anOdsSheet.ods&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PyObject &lt;ezodf.document.PackagedDocument object at 0x7fabd9958af0&gt;</code></pre><p>Both <code>ez</code> and <code>destDoc</code> are <code>PyObjects</code> for which we can access attributes and call the methods using the usual <code>obj.method()</code> syntax as we would do in Python</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sheet    = ez.Sheet(&quot;Sheet1&quot;, size=(10, 10))</code><code class="nohighlight hljs ansi" style="display:block;">PyObject &lt;ezodf.table.Table object at 0x7fabd9958280&gt;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; destDoc.sheets.append(sheet)
       # dcell1 = sheet[(2,3)] # This would error because the index is a tuple. Let&#39;s use directly the `get(obj,key)` function instead:</code><code class="nohighlight hljs ansi" style="display:block;">PyObject &lt;ezodf.table.Table object at 0x7fabd9958280&gt;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcell1   = get(sheet,(2,3)) # Equiv. of Python `dcell1 = sheet[(2,3)]`. Attention again to Python indexing from zero: this is cell &quot;D3&quot;, not &quot;B3&quot; !</code><code class="nohighlight hljs ansi" style="display:block;">PyObject &lt;ezodf.cells.Cell object at 0x7fabd99581f0&gt;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcell1.set_value(&quot;Hello&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; get(sheet,&quot;A9&quot;).set_value(10.5) # Equiv. of Python `sheet[&#39;A9&#39;].set_value(10.5)`</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; destDoc.backup = false</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; destDoc.save()</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h3 id="Using-Julia-in-Python"><a class="docs-heading-anchor" href="#Using-Julia-in-Python">Using Julia in Python</a><a id="Using-Julia-in-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Julia-in-Python" title="Permalink"></a></h3><h4 id="Installation-of-the-Python-package-PyJulia"><a class="docs-heading-anchor" href="#Installation-of-the-Python-package-PyJulia">Installation of the Python package <code>PyJulia</code></a><a id="Installation-of-the-Python-package-PyJulia-1"></a><a class="docs-heading-anchor-permalink" href="#Installation-of-the-Python-package-PyJulia" title="Permalink"></a></h4><p><a href="https://github.com/JuliaPy/pyjulia">PyJulia</a> can be installed using <code>pip</code>, taking note that its name using <code>pip</code> is <code>julia</code> not <code>PyJulia</code>: <code>$ python3 -m pip install --user julia</code></p><p>We can now open a Python terminal and initialise PyJulia to work with our Julia version:</p><pre><code class="language-python hljs">&gt;&gt;&gt; import julia
&gt;&gt;&gt; julia.install() # Only once to set-up in julia the julia packages required by PyJulia</code></pre><p>If we have multiple Julia versions, we can specify the one to use in Python passing julia=&quot;/path/to/julia/binary/executable&quot; (e.g. julia = &quot;/home/myUser/lib/julia-1.1.0/bin/julia&quot;) to the install() function.</p><h4 id="Running-Julia-libraries-and-code-in-Python"><a class="docs-heading-anchor" href="#Running-Julia-libraries-and-code-in-Python">Running Julia libraries and code in Python</a><a id="Running-Julia-libraries-and-code-in-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Running-Julia-libraries-and-code-in-Python" title="Permalink"></a></h4><p>On each Python session we need to run the following code:</p><pre><code class="language-python hljs">from julia import Julia
Julia(compiled_modules=False)</code></pre><p>This is a workaround to the common situation when the Python interpreter is statically linked to libpython, but it will slow down the interactive experience, as it will disable Julia packages pre-compilation, and every time we will use a module for the first time, this will need to be compiled first. Other, more efficient but also more complicate, workarounds are given in the package documentation, under the <a href="https://pyjulia.readthedocs.io/en/stable/troubleshooting.html">Troubleshooting section</a>.</p><p>We can now direcltly load a Julia module, including <code>Main</code>, the global namespace of Julia’s interpreter, with <code>from julia import ModuleToLoad</code> and access the module objects directly or using the <code>Module.evel()</code> interface.</p><h5 id="Add-a-Julia-package..."><a class="docs-heading-anchor" href="#Add-a-Julia-package...">Add a Julia package...</a><a id="Add-a-Julia-package...-1"></a><a class="docs-heading-anchor-permalink" href="#Add-a-Julia-package..." title="Permalink"></a></h5><pre><code class="language-python hljs">&gt;&gt;&gt; from julia import Pkg
&gt;&gt;&gt; Pkg.add(&quot;BetaML&quot;)</code></pre><p>Of course we can add a package alternatively from within Julia</p><h5 id="&quot;Direct&quot;-calling-of-Julia-functions..."><a class="docs-heading-anchor" href="#&quot;Direct&quot;-calling-of-Julia-functions...">&quot;Direct&quot; calling of Julia functions...</a><a id="&quot;Direct&quot;-calling-of-Julia-functions...-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;Direct&quot;-calling-of-Julia-functions..." title="Permalink"></a></h5><pre><code class="language-python hljs">&gt;&gt;&gt; from julia import BetaML
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; model = BetaML.buildForest([[1,10],[2,12],[12,1]],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;])
&gt;&gt;&gt; predictions = BetaML.predict(model,np.array([[2,9],[13,0]]))
&gt;&gt;&gt; predictions
[{&#39;b&#39;: 0.36666666666666664, &#39;a&#39;: 0.6333333333333333}, {&#39;b&#39;: 0.7333333333333333, &#39;a&#39;: 0.26666666666666666}]</code></pre><h5 id="Access-using-the-eval()-interface..."><a class="docs-heading-anchor" href="#Access-using-the-eval()-interface...">Access using the <code>eval()</code> interface...</a><a id="Access-using-the-eval()-interface...-1"></a><a class="docs-heading-anchor-permalink" href="#Access-using-the-eval()-interface..." title="Permalink"></a></h5><p>If we are using the jl.eval() interface, the objects we use must be already known to julia. To pass objects from Python to Julia, we can import the julia Main module (the root module in julia) and assign the needed variables, e.g.</p><pre><code class="language-python hljs">&gt;&gt;&gt; X_python = [1,2,3,2,4]
&gt;&gt;&gt; from julia import Main
&gt;&gt;&gt; Main.X_julia = X_python
&gt;&gt;&gt; Main.eval(&#39;BetaML.gini(X_julia)&#39;)
0.7199999999999999
&gt;&gt;&gt; Main.eval(&quot;&quot;&quot;
...   function makeProd(x,y)
...       return x*y
...   end
...   &quot;&quot;&quot;
... )
&gt;&gt;&gt; Main.eval(&quot;makeProd(2,3)&quot;) # or Main.makeProd(2,3)</code></pre><p>For large scripts instead of using <code>eval()</code> we can equivalently use <code>Main.include(&quot;aJuliaScript.jl&quot;)</code></p><h3 id="Using-R-in-Julia"><a class="docs-heading-anchor" href="#Using-R-in-Julia">Using R in Julia</a><a id="Using-R-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Using-R-in-Julia" title="Permalink"></a></h3><p>To use R from within Julia we use the <a href="https://github.com/JuliaInterop/RCall.jl">RCall</a> package.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ENV[&quot;R_HOME&quot;] = &quot;*&quot; #  # will force RCall to download and use a &quot;private to Julia&quot; (conda based) version of R. use &quot;/path/to/R/directory&quot; (e.g. `/usr/lib/R`) if you want to reuse a version already installed on your system
       
       # using Pkg
       # Pkg.add(&quot;RCall&quot;)
       # Pkg.build(&quot;RCall&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;*&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using RCall</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R&quot;&quot;&quot;
       sumMyArgs &lt;- function(i,j) i+j
       getNthElement &lt;- function(vec,n) {
         return(vec[n])
       }
       &quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">RCall.RObject{RCall.ClosSxp}
function (vec, n)
{
    return(vec[n])
}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = rcopy(R&quot;sumMyArgs&quot;(3,4))             # 7 - here we call the R object (a function) with Julia parameters</code><code class="nohighlight hljs ansi" style="display:block;">7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = rcopy(R&quot;getNthElement&quot;([1,2,3],1))   # 1 - no differences in array indexing here</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = rcopy(R&quot;as.integer(getNthElement(c(1,$a,3),2))&quot;)  # 7 - here we interpolate the R call</code><code class="nohighlight hljs ansi" style="display:block;">7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = convert(Int64,R&quot;getNthElement(c(1,$a,3),2)&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">7</code></pre><p>While we don&#39;t have here the problem of different array indexing convention (both Julia and R start indexing arrays at 1), we have the &quot;problem&quot; that the output returned by using <code>R&quot;...&quot;</code> is not yet an exploitable Julia object but it remains as an <code>RObject</code> that we can convert with <code>rcopy()</code> or explicitly with <code>convert(T,obj)</code>. Also, R elements are all floats by default, so if we need an integer in Julia we need to explicitly convert it, either in R or in Julia.</p><p>If the R code is on a script, we don&#39;t have here a sort of @Rinclude macro, so let&#39;s implement it ourselves by loading the file content as a file and evaluating it using the function <code>reval</code> provided by <code>RCall</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; macro Rinclude(fname)
           quote
               rCodeString = read($fname,String)
               reval(rCodeString)
               nothing
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">@Rinclude (macro with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; RCode = &quot;&quot;&quot;
       sumMyArgs &lt;- function(i, j, z) i+j+z
       &quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;sumMyArgs &lt;- function(i, j, z) i+j+z\n&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; open(f-&gt;write(f,RCode),&quot;RScript.R&quot;,&quot;w&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">37</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @Rinclude(&quot;RScript.R&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = rcopy(R&quot;sumMyArgs&quot;(3,4,5))  # 12
       # a = rcopy(R&quot;sumMyArgs&quot;(3,4)) # error !  The 3-arguments version of `sumMyArgs` has _replaced_ the 2-arguments one</code><code class="nohighlight hljs ansi" style="display:block;">12</code></pre><h3 id="Using-Julia-in-R"><a class="docs-heading-anchor" href="#Using-Julia-in-R">Using Julia in R</a><a id="Using-Julia-in-R-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Julia-in-R" title="Permalink"></a></h3><h4 id="Installation-of-the-R-package-JuliaCall"><a class="docs-heading-anchor" href="#Installation-of-the-R-package-JuliaCall">Installation of the R package <code>JuliaCall</code></a><a id="Installation-of-the-R-package-JuliaCall-1"></a><a class="docs-heading-anchor-permalink" href="#Installation-of-the-R-package-JuliaCall" title="Permalink"></a></h4><p><a href="https://github.com/Non-Contradiction/JuliaCall">JuliaCall</a> can be installed from CRAN:</p><pre><code class="language- hljs">&gt; install.packages(&quot;JuliaCall&quot;)
&gt; library(JuliaCall)
install_julia()</code></pre><p><code>install_julia()</code> will force the download of R and install a private copy of julia. If you prefer to use instead an existing version of julia and having R default to download a private version only if it can&#39;t find a version already installed, use <code>julia_setup(installJulia = TRUE)</code> instead of <code>install_julia()</code>, eventually passing the <code>JULIA_HOME = &quot;/path/to/julia/binary/executable/directory&quot;</code> (e.g. <code>JULIA_HOME = &quot;/home/myUser/lib/julia-1.7.0/bin&quot;</code>) parameter to the <code>julia_setup</code> call.</p><p><code>JuliaCall</code> depends for some things (like object conversion between Julia and R) from the Julia <code>RCall</code> package. If we don&#39;t already have it installed in Julia, it will try to install it automatically.</p><h4 id="Running-Julia-libraries-and-code-in-R"><a class="docs-heading-anchor" href="#Running-Julia-libraries-and-code-in-R">Running Julia libraries and code in R</a><a id="Running-Julia-libraries-and-code-in-R-1"></a><a class="docs-heading-anchor-permalink" href="#Running-Julia-libraries-and-code-in-R" title="Permalink"></a></h4><p>On each R session we need to run the <code>julia_setup</code> function:</p><pre><code class="language-R hljs">library(JuliaCall)
julia_setup() # If we have already downloaded a private version of Julia for R it will be retrieved automatically</code></pre><p>We can now load a Julia module and access the module objects directly or using the <code>Module.evel()</code> interface.</p><h5 id="Add-a-Julia-package...-2"><a class="docs-heading-anchor" href="#Add-a-Julia-package...-2">Add a Julia package...</a><a class="docs-heading-anchor-permalink" href="#Add-a-Julia-package...-2" title="Permalink"></a></h5><pre><code class="language- hljs">&gt; julia_eval(&#39;using Pkg; Pkg.add(&quot;BetaML&quot;)&#39;)</code></pre><p>Of course we can add a package alternatively from within Julia</p><p>Let&#39;s load some data from R and do some work with this data in Julia:</p><pre><code class="language- hljs">&gt; library(datasets)
&gt; X &lt;- as.matrix(sapply(iris[,1:4], as.numeric))
&gt; y &lt;- sapply(iris[,5], as.integer)</code></pre><h5 id="Calling-of-Julia-functions-with-julia_call..."><a class="docs-heading-anchor" href="#Calling-of-Julia-functions-with-julia_call...">Calling of Julia functions with <code>julia_call</code>...</a><a id="Calling-of-Julia-functions-with-julia_call...-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-of-Julia-functions-with-julia_call..." title="Permalink"></a></h5><p>With <code>JuliaCall</code>, differently than <code>PyJulia</code>, we can&#39;t call direclty the julia functions but we need to employ the R function <code>julia_call(&quot;juliaFunction&quot;,args)</code>:</p><pre><code class="language- hljs">&gt; julia_eval(&quot;using BetaML&quot;)
&gt; yencoded &lt;- julia_call(&quot;integerEncoder&quot;,y)
&gt; ids      &lt;- julia_call(&quot;shuffle&quot;,1:length(y))
&gt; Xs       &lt;- X[ids,]
&gt; ys       &lt;- yencoded[ids]
&gt; cOut     &lt;- julia_call(&quot;kmeans&quot;,Xs,3L)    # kmeans expects K to be an integer
&gt; y_hat    &lt;- sapply(cOut[1],as.integer)[,] # We need a vector, not a matrix
&gt; acc      &lt;- julia_call(&quot;accuracy&quot;,y_hat,ys)
&gt; acc
[1] 0.8933333</code></pre><h5 id="Access-using-the-eval()-interface...-2"><a class="docs-heading-anchor" href="#Access-using-the-eval()-interface...-2">Access using the <code>eval()</code> interface...</a><a class="docs-heading-anchor-permalink" href="#Access-using-the-eval()-interface...-2" title="Permalink"></a></h5><p>As alternative, we can embed Julia code directly in R using the <code>julia_eval()</code> function:</p><pre><code class="language- hljs">&gt; kMeansR  &lt;- julia_eval(&#39;
+      function accFromKmeans(x,k,y_true)
+        cOut = kmeans(x,Int(k))
+        acc = accuracy(cOut[1],y_true)
+        return acc
+      end
+ &#39;)</code></pre><p>We can then call the above function in R in one of the following three ways:</p><ol><li><code>kMeansR(Xs,3,ys)</code></li><li><code>julia_assign(&quot;Xs_julia&quot;, Xs); julia_assign(&quot;ys_julia&quot;, ys); julia_eval(&quot;accFromKmeans(Xs_julia,3,ys_julia)&quot;)</code></li><li><code>julia_call(&quot;accFromKmeans&quot;,Xs,3,ys)</code>.</li></ol><p>While other &quot;convenience&quot; functions are provided by the package, using  <code>julia_call</code> or <code>julia_assign</code> followed by <code>julia_eval</code> should suffix to accomplish most of the task we may need in Julia.</p><h2 id="Some-performance-tips"><a class="docs-heading-anchor" href="#Some-performance-tips">Some performance tips</a><a id="Some-performance-tips-1"></a><a class="docs-heading-anchor-permalink" href="#Some-performance-tips" title="Permalink"></a></h2><h3 id="Type-stability"><a class="docs-heading-anchor" href="#Type-stability">Type stability</a><a id="Type-stability-1"></a><a class="docs-heading-anchor-permalink" href="#Type-stability" title="Permalink"></a></h3><p>&quot;Type stable&quot; functions guarantee to the compiler that given a certain method (i.e. with the arguments being of a given type) the object returned by the function is also of a certain fixed type. Type stability is fundamental to allow type inference continue across the function call stack.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f1(x)    # Type unstable
           outVector = [1,2.0,&quot;2&quot;]
           if x &lt; 0
               return outVector[1]
           elseif x == 0
               return outVector[2]
           else
               return outVector[3]
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">f1 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f2(x)   # Type stable
           outVector = [1,convert(Int64,2.0),parse(Int64,&quot;2&quot;)]
           if x &lt; 0
               return outVector[1]
           elseif x == 0
               return outVector[2]
           else
               return outVector[3]
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">f2 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = f1(0)</code><code class="nohighlight hljs ansi" style="display:block;">2.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = f1(1)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;2&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">Float64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(b)</code><code class="nohighlight hljs ansi" style="display:block;">String</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = f2(0)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = f2(1)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(c)</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(d)</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using BenchmarkTools</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f1(0) # 661 ns 6 allocations</code><code class="nohighlight hljs ansi" style="display:block;">  75.106 ns (5 allocations: 192 bytes)
2.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f2(0) #  55 ns 1 allocations</code><code class="nohighlight hljs ansi" style="display:block;">  46.519 ns (1 allocation: 80 bytes)
2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_warntype f1(0) # Body::Any</code><code class="nohighlight hljs ansi" style="display:block;">MethodInstance for Main.var&quot;Main&quot;.f1(::Int64)
  from f1(x) @ Main.var&quot;Main&quot; REPL[1]:1
Arguments
  #self#::Core.Const(Main.var&quot;Main&quot;.f1)
  x::Int64
Locals
  outVector::Vector{Any}
Body::ANY
1 ─       (outVector = Base.vect(1, 2.0, &quot;2&quot;))
│   %2  = (x &lt; 0)::Bool
└──       goto #3 if not %2
2 ─ %4  = Base.getindex(outVector, 1)::ANY
└──       return %4
3 ─ %6  = (x == 0)::Bool
└──       goto #5 if not %6
4 ─ %8  = Base.getindex(outVector, 2)::ANY
└──       return %8
5 ─ %10 = Base.getindex(outVector, 3)::ANY
└──       return %10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_warntype f2(0) # Body::Int64</code><code class="nohighlight hljs ansi" style="display:block;">MethodInstance for Main.var&quot;Main&quot;.f2(::Int64)
  from f2(x) @ Main.var&quot;Main&quot; REPL[2]:1
Arguments
  #self#::Core.Const(Main.var&quot;Main&quot;.f2)
  x::Int64
Locals
  outVector::Vector{Int64}
Body::Int64
1 ─ %1  = Main.var&quot;Main&quot;.convert(Main.var&quot;Main&quot;.Int64, 2.0)::Core.Const(2)
│   %2  = Main.var&quot;Main&quot;.parse(Main.var&quot;Main&quot;.Int64, &quot;2&quot;)::Int64
│         (outVector = Base.vect(1, %1, %2))
│   %4  = (x &lt; 0)::Bool
└──       goto #3 if not %4
2 ─ %6  = Base.getindex(outVector, 1)::Int64
└──       return %6
3 ─ %8  = (x == 0)::Bool
└──       goto #5 if not %8
4 ─ %10 = Base.getindex(outVector, 2)::Int64
└──       return %10
5 ─ %12 = Base.getindex(outVector, 3)::Int64
└──       return %12</code></pre><p>While in general it is NOT important to annotate function parameters for performance, it is important to annotate struct fields with concrete types</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; abstract type Goo end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Foo &lt;: Goo
           x::Number
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Boo &lt;: Goo
           x::Int64
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f1(o::Goo)
           return o.x +2
       end</code><code class="nohighlight hljs ansi" style="display:block;">f1 (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fobj = Foo(1)</code><code class="nohighlight hljs ansi" style="display:block;">Main.var&quot;Main&quot;.Foo(1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bobj = Boo(1)</code><code class="nohighlight hljs ansi" style="display:block;">Main.var&quot;Main&quot;.Boo(1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f1($fobj) # 17.1 ns 0 allocations</code><code class="nohighlight hljs ansi" style="display:block;">  20.047 ns (0 allocations: 0 bytes)
3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f1($bobj) #  2.8 ns 0 allocations</code><code class="nohighlight hljs ansi" style="display:block;">  2.785 ns (0 allocations: 0 bytes)
3</code></pre><p>Here the same function under some argument types is type stable, under other argument types is not</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_warntype f1(fobj)</code><code class="nohighlight hljs ansi" style="display:block;">MethodInstance for Main.var&quot;Main&quot;.f1(::Main.var&quot;Main&quot;.Foo)
  from f1(o::Main.var&quot;Main&quot;.Goo) @ Main.var&quot;Main&quot; REPL[4]:1
Arguments
  #self#::Core.Const(Main.var&quot;Main&quot;.f1)
  o::Main.var&quot;Main&quot;.Foo
Body::ANY
1 ─ %1 = Base.getproperty(o, :x)::NUMBER
│   %2 = (%1 + 2)::ANY
└──      return %2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_warntype f1(bobj)</code><code class="nohighlight hljs ansi" style="display:block;">MethodInstance for Main.var&quot;Main&quot;.f1(::Main.var&quot;Main&quot;.Boo)
  from f1(o::Main.var&quot;Main&quot;.Goo) @ Main.var&quot;Main&quot; REPL[4]:1
Arguments
  #self#::Core.Const(Main.var&quot;Main&quot;.f1)
  o::Main.var&quot;Main&quot;.Boo
Body::Int64
1 ─ %1 = Base.getproperty(o, :x)::Int64
│   %2 = (%1 + 2)::Int64
└──      return %2</code></pre><h4 id="Avoid-(non-constant)-global-variables"><a class="docs-heading-anchor" href="#Avoid-(non-constant)-global-variables">Avoid (non-constant) global variables</a><a id="Avoid-(non-constant)-global-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-(non-constant)-global-variables" title="Permalink"></a></h4><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; g        = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; const cg = 1   # we can&#39;t change the _type_ of the object binded to a constant variable</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cg       = 2   # we can rebind to an other object of the same type, but we get a warning
       # cg    = 2.5 # this would error !</code><code class="nohighlight hljs ansi" style="display:block;">WARNING: redefinition of constant Main.cg. This may fail, cause incorrect answers, or produce other errors.
2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f1(x,y) = x+y</code><code class="nohighlight hljs ansi" style="display:block;">f1 (generic function with 3 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f2(x)   = x + g</code><code class="nohighlight hljs ansi" style="display:block;">f2 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f3(x)   = x + cg</code><code class="nohighlight hljs ansi" style="display:block;">f3 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f1(3,2)</code><code class="nohighlight hljs ansi" style="display:block;">  1.552 ns (0 allocations: 0 bytes)
5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f2(3)    # 22 times slower !!!</code><code class="nohighlight hljs ansi" style="display:block;">  20.962 ns (0 allocations: 0 bytes)
5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f3(3)    # as f1</code><code class="nohighlight hljs ansi" style="display:block;">  1.552 ns (0 allocations: 0 bytes)
5</code></pre><h4 id="Loop-arrays-with-the-inner-loop-by-rows"><a class="docs-heading-anchor" href="#Loop-arrays-with-the-inner-loop-by-rows">Loop arrays with the inner loop by rows</a><a id="Loop-arrays-with-the-inner-loop-by-rows-1"></a><a class="docs-heading-anchor-permalink" href="#Loop-arrays-with-the-inner-loop-by-rows" title="Permalink"></a></h4><p>Julia is column mayor (differently than Python) so arrays of bits types are contiguous in memory across the different rows of the same column</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = rand(1000,1000);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f1(x)
           (R,C) = size(x)
           cum = 0.0
           for r in 1:R
               for c in 1:C
                   cum += x[r,c]
               end
           end
           return cum
       end</code><code class="nohighlight hljs ansi" style="display:block;">f1 (generic function with 3 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f2(x)
           (R,C) = size(x)
           cum = 0.0
           for c in 1:C
               for r in 1:R
                   cum += x[r,c]
               end
           end
           return cum
       end</code><code class="nohighlight hljs ansi" style="display:block;">f2 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f1($a) # 2.3 ms 0 allocations</code><code class="nohighlight hljs ansi" style="display:block;">  926.449 μs (0 allocations: 0 bytes)
500220.6882968228</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f2($a) # 1.3 ms 0 allocations</code><code class="nohighlight hljs ansi" style="display:block;">  925.564 μs (0 allocations: 0 bytes)
500220.6882968189</code></pre><h4 id="Use-low-level-optimisation-when-possible"><a class="docs-heading-anchor" href="#Use-low-level-optimisation-when-possible">Use low-level optimisation when possible</a><a id="Use-low-level-optimisation-when-possible-1"></a><a class="docs-heading-anchor-permalink" href="#Use-low-level-optimisation-when-possible" title="Permalink"></a></h4><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f1(x)
           s = 0.0
           for i in 1:length(x)
               s += i * x[i]
           end
           return s
       end</code><code class="nohighlight hljs ansi" style="display:block;">f1 (generic function with 3 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f2(x)
           s = 0.0
           for i in 1:length(x)
               @inbounds s += i * x[i] # remove bound checks
           end
           return s
       end</code><code class="nohighlight hljs ansi" style="display:block;">f2 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f3(x)
           s = 0.0
           @simd for i in 1:length(x) # tell compiler it is allowed to run the loop in whatever order, allowing in-thread paralllelism of modern CPUs
               s += i * x[i]
           end
           return s
       end</code><code class="nohighlight hljs ansi" style="display:block;">f3 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = rand(10000);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f1($x)</code><code class="nohighlight hljs ansi" style="display:block;">  9.267 μs (0 allocations: 0 bytes)
2.5231610262164485e7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f2($x)</code><code class="nohighlight hljs ansi" style="display:block;">  9.257 μs (0 allocations: 0 bytes)
2.5231610262164485e7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f3($x)</code><code class="nohighlight hljs ansi" style="display:block;">  5.559 μs (0 allocations: 0 bytes)
2.5231610262164526e7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; X = rand(100,20);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f1(x)
           s = 0.0
           for i in 1:size(x,1)
               s += sum(x[i,:])
           end
           return s
       end</code><code class="nohighlight hljs ansi" style="display:block;">f1 (generic function with 3 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f2(x)
           s = 0.0
           @views for i in 1:size(x,1)
               s += sum(x[i,:])   # the slice operator copy the data.. the views macro force to have instead to have a view (reference)
           end
           return s
       end</code><code class="nohighlight hljs ansi" style="display:block;">f2 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f1($X)</code><code class="nohighlight hljs ansi" style="display:block;">  4.225 μs (100 allocations: 21.88 KiB)
1013.9993057955776</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f2($X)</code><code class="nohighlight hljs ansi" style="display:block;">  1.314 μs (0 allocations: 0 bytes)
1013.9993057955776</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Attention that while the <code>@views</code> macro &quot;save time&quot; by not copying the data, the resulting array has a pretty messy layout. If you need to use it for many subsequent operations it may be more efficient to &quot;pay&quot; the copy cost once and then have an array with a nicelly continuous block of memory..</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f1(x,y)
           if x+y &gt; 100
               return x + y + 2
           else
               return x + 1
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">f1 (generic function with 3 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @inline function f2(x,y)   # the function is &quot;inlined&quot;, its whole definition copied at each calling place rather than being called
           if x+y &gt; 100
               return x + y + 2
           else
               return x + 1
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">f2 (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f3(y)
           s = 0.0
           for i in 2:y
              s += f1(i,i-1)
              s += f1(i,i)
           end
           return s
        end</code><code class="nohighlight hljs ansi" style="display:block;">f3 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f4(y)
           s = 0.0
           for i in 2:y
              s += f2(i,i-1)
              s += f2(i,i)
           end
           return s
       end</code><code class="nohighlight hljs ansi" style="display:block;">f4 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 1000</code><code class="nohighlight hljs ansi" style="display:block;">1000</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f3($x)</code><code class="nohighlight hljs ansi" style="display:block;">  1.851 μs (0 allocations: 0 bytes)
2.002396e6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f4($x)</code><code class="nohighlight hljs ansi" style="display:block;">  1.834 μs (0 allocations: 0 bytes)
2.002396e6</code></pre><p>But attention! Not always a good idea:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f3(y)
           s = 0.0
           for i in 2:y
              s += sum(f1(a,a-1) for a in 2:i)
           end
           return s
        end</code><code class="nohighlight hljs ansi" style="display:block;">f3 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f4(y)
           s = 0.0
           for i in 2:y
              s += sum(f2(a,a-1) for a in 2:i)
           end
           return s
       end</code><code class="nohighlight hljs ansi" style="display:block;">f4 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 1000</code><code class="nohighlight hljs ansi" style="display:block;">1000</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f3($x)</code><code class="nohighlight hljs ansi" style="display:block;">  86.201 μs (0 allocations: 0 bytes)
3.3359915e8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime f4($x)</code><code class="nohighlight hljs ansi" style="display:block;">  86.061 μs (0 allocations: 0 bytes)
3.3359915e8</code></pre><p>Note that the Julia compiles already inline small functions automatically when it thinks it will improve performances</p><h2 id="Profiling-the-code-to-discover-bootlenecks"><a class="docs-heading-anchor" href="#Profiling-the-code-to-discover-bootlenecks">Profiling the code to discover bootlenecks</a><a id="Profiling-the-code-to-discover-bootlenecks-1"></a><a class="docs-heading-anchor-permalink" href="#Profiling-the-code-to-discover-bootlenecks" title="Permalink"></a></h2><p>We already see <code>@btime</code> and <code>@benchmark</code> from the package <a href="https://github.com/JuliaCI/BenchmarkTools.jl">BenchmarkTools.jl</a> Remember to quote the global variables used as parameter of your function with the dollar sign to have accurate benchmarking of the function execution. Julia provide the macro <code>@time</code> but we should run on a second call to a given function (with a certain parameter types) or it will include compilation time in its output:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function fb(x)
           out = Union{Int64,Float64}[1,2.0,3]
           push!(out,4)
           if x &gt; 10
               if ( x &gt; 100)
                   return [out[1],out[2]] |&gt;  sum
               else
                   return [out[2],out[3]] |&gt;  sum
               end
           else
               return [out[1],out[3]] |&gt;  sum
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">fb (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time fb(3)</code><code class="nohighlight hljs ansi" style="display:block;">  0.000006 seconds (3 allocations: 256 bytes)
4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time fb(3)</code><code class="nohighlight hljs ansi" style="display:block;">  0.000005 seconds (3 allocations: 256 bytes)
4</code></pre><p>We can use <code>@profile function(x,y)</code> to use a sample-based profiling</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Profile # in the stdlib</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function foo(n)
           a = rand(n,n)
           b = a + a
           c = b * b
           return c
       end</code><code class="nohighlight hljs ansi" style="display:block;">foo (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @profile (for i = 1:100; foo(1000); end) # too fast otherwise</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Profile.print() # on my pc: 243 rand, 174 the sum, 439 the matrix product</code><code class="nohighlight hljs ansi" style="display:block;">Overhead ╎ [+additional indent] Count File:Line; Function
=========================================================
    ╎242   @Base/client.jl:552; _start()
    ╎ 242   @Base/client.jl:318; exec_options(opts::Base.JLOptions)
    ╎  242   @Base/Base.jl:495; include(mod::Module, _path::String)
    ╎   242   @Base/loading.jl:2136; _include(mapexpr::Function, mod::Module, _…
    ╎    242   @Base/loading.jl:2076; include_string(mapexpr::typeof(identity),…
    ╎     242   @Base/boot.jl:385; eval
    ╎    ╎ 242   …ter/src/makedocs.jl:265; kwcall(::@NamedTuple{sitename::Strin…
    ╎    ╎  242   …er/src/makedocs.jl:271; #makedocs#87
    ╎    ╎   242   @Base/file.jl:112; cd(f::Documenter.var&quot;#88#90&quot;{Documenter.D…
    ╎    ╎    242   …r/src/makedocs.jl:271; #88
    ╎    ╎     242   @Base/env.jl:257; withenv(::Documenter.var&quot;#89#91&quot;{Documen…
    ╎    ╎    ╎ 242   …r/src/makedocs.jl:272; #89
    ╎    ╎    ╎  242   …ies/Selectors.jl:170; dispatch(::Type{Documenter.Builde…
    ╎    ╎    ╎   242   …lder_pipeline.jl:222; runner(::Type{Documenter.Builder…
    ╎    ╎    ╎    242   …nder_pipeline.jl:22; expand(doc::Documenter.Document)
    ╎    ╎    ╎     242   …es/Selectors.jl:170; dispatch(::Type{Documenter.Expa…
    ╎    ╎    ╎    ╎ 242   …der_pipeline.jl:846; runner(::Type{Documenter.Expan…
    ╎    ╎    ╎    ╎  242   …c/IOCapture.jl:100; kwcall(::@NamedTuple{rethrow::…
    ╎    ╎    ╎    ╎   242   …c/IOCapture.jl:167; capture(f::Documenter.var&quot;#63…
    ╎    ╎    ╎    ╎    242   …se/logging.jl:627; with_logger
    ╎    ╎    ╎    ╎     242   …se/logging.jl:515; with_logstate(f::Function, l…
    ╎    ╎    ╎    ╎    ╎ 242   …/IOCapture.jl:170; (::IOCapture.var&quot;#5#9&quot;{Data…
    ╎    ╎    ╎    ╎    ╎  242   …_pipeline.jl:847; (::Documenter.var&quot;#63#65&quot;{D…
    ╎    ╎    ╎    ╎    ╎   242   @Base/file.jl:112; cd(f::Documenter.var&quot;#64#6…
    ╎    ╎    ╎    ╎    ╎    242   …pipeline.jl:848; #64
    ╎    ╎    ╎    ╎    ╎     242   …ase/boot.jl:385; eval
    ╎    ╎    ╎    ╎    ╎    ╎ 242   REPL[3]:1; top-level scope
    ╎    ╎    ╎    ╎    ╎    ╎  242   …/Profile.jl:44; macro expansion
    ╎    ╎    ╎    ╎    ╎    ╎   242   REPL[3]:1; macro expansion
    ╎    ╎    ╎    ╎    ╎    ╎    107   REPL[2]:2; foo(n::Int64)
    ╎    ╎    ╎    ╎    ╎    ╎     107   …c/Random.jl:279; rand
    ╎    ╎    ╎    ╎    ╎    ╎    ╎ 107   …c/Random.jl:291; rand
    ╎    ╎    ╎    ╎    ╎    ╎    ╎  107   …c/Random.jl:290; rand
    ╎    ╎    ╎    ╎    ╎    ╎    ╎   3     …ase/boot.jl:494; Array
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    3     …ase/boot.jl:487; Array
   3╎    ╎    ╎    ╎    ╎    ╎    ╎     3     …ase/boot.jl:479; Array
    ╎    ╎    ╎    ╎    ╎    ╎    ╎   104   …c/Random.jl:269; rand!
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    104   …hiroSimd.jl:293; rand!
    ╎    ╎    ╎    ╎    ╎    ╎    ╎     104   …hiroSimd.jl:142; xoshiro_bulk
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎ 4     …hiroSimd.jl:249; xoshiro_bulk_s…
   4╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎  4     …hiroSimd.jl:71; _plus
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎ 1     …hiroSimd.jl:252; xoshiro_bulk_s…
   1╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎  1     …hiroSimd.jl:77; _xor
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎ 2     …hiroSimd.jl:253; xoshiro_bulk_s…
   2╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎  2     …hiroSimd.jl:77; _xor
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎ 1     …hiroSimd.jl:254; xoshiro_bulk_s…
   1╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎  1     …hiroSimd.jl:77; _xor
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎ 1     …hiroSimd.jl:255; xoshiro_bulk_s…
   1╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎  1     …hiroSimd.jl:77; _xor
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎ 95    …hiroSimd.jl:257; xoshiro_bulk_s…
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎  29    …/pointer.jl:146; unsafe_store!
  29╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎   29    …/pointer.jl:146; unsafe_store!
  66╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎  66    …hiroSimd.jl:108; _bits2float
    ╎    ╎    ╎    ╎    ╎    ╎    68    REPL[2]:3; foo(n::Int64)
    ╎    ╎    ╎    ╎    ╎    ╎     68    …rraymath.jl:16; +(A::Matrix{Float64},…
    ╎    ╎    ╎    ╎    ╎    ╎    ╎ 68    …roadcast.jl:892; broadcast_preservin…
    ╎    ╎    ╎    ╎    ╎    ╎    ╎  68    …roadcast.jl:903; materialize
    ╎    ╎    ╎    ╎    ╎    ╎    ╎   68    …roadcast.jl:928; copy
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    64    …roadcast.jl:956; copyto!
    ╎    ╎    ╎    ╎    ╎    ╎    ╎     64    …roadcast.jl:1003; copyto!
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎ 63    …simdloop.jl:77; macro expansion
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎  63    …roadcast.jl:1004; macro expans…
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎   18    …roadcast.jl:636; getindex
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎    15    …roadcast.jl:681; _broadcast_…
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎     15    …roadcast.jl:705; _getindex
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎  +1 15    …roadcast.jl:675; _broadcast…
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎  +2 15    …ensional.jl:696; getindex
  15╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎  +3 15    …sentials.jl:14; getindex
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎    3     …roadcast.jl:682; _broadcast_…
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎     3     …roadcast.jl:709; _broadcast…
   3╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎  +1 3     …se/float.jl:409; +
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎   45    …ensional.jl:698; setindex!
  45╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎    45    …se/array.jl:1024; setindex!
   1╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎ 1     …simdloop.jl:84; macro expansion
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    4     …roadcast.jl:223; similar
    ╎    ╎    ╎    ╎    ╎    ╎    ╎     4     …roadcast.jl:224; similar
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎ 4     …actarray.jl:876; similar
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎  4     …actarray.jl:877; similar
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎   4     …ase/boot.jl:494; Array
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎    4     …ase/boot.jl:487; Array
   4╎    ╎    ╎    ╎    ╎    ╎    ╎    ╎     4     …ase/boot.jl:479; Array
    ╎    ╎    ╎    ╎    ╎    ╎    67    REPL[2]:4; foo(n::Int64)
    ╎    ╎    ╎    ╎    ╎    ╎     67    …c/matmul.jl:113; *(A::Matrix{Float64}…
    ╎    ╎    ╎    ╎    ╎    ╎    ╎ 11    …se/array.jl:420; similar
    ╎    ╎    ╎    ╎    ╎    ╎    ╎  11    …ase/boot.jl:487; Array
  11╎    ╎    ╎    ╎    ╎    ╎    ╎   11    …ase/boot.jl:479; Array
    ╎    ╎    ╎    ╎    ╎    ╎    ╎ 56    …c/matmul.jl:237; mul!
    ╎    ╎    ╎    ╎    ╎    ╎    ╎  56    …c/matmul.jl:263; mul!
    ╎    ╎    ╎    ╎    ╎    ╎    ╎   56    …c/matmul.jl:352; generic_matmatmul!
    ╎    ╎    ╎    ╎    ╎    ╎    ╎    56    …c/matmul.jl:605; gemm_wrapper!(C:…
  56╎    ╎    ╎    ╎    ╎    ╎    ╎     56    …src/blas.jl:1524; gemm!(transA::…
    ╎6114  @Base/task.jl:682; task_done_hook(t::Task)
    ╎ 6114  @Base/task.jl:1008; wait()
6114╎  6114  @Base/task.jl:999; poptask(W::Base.IntrusiveLinkedListSynchronized…
Total snapshots: 10190. Utilization: 40% across all threads and tasks. Use the `groupby` kwarg to break down by thread and/or task.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Profile.clear()</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h2 id="Introspection-and-debugging"><a class="docs-heading-anchor" href="#Introspection-and-debugging">Introspection and debugging</a><a id="Introspection-and-debugging-1"></a><a class="docs-heading-anchor-permalink" href="#Introspection-and-debugging" title="Permalink"></a></h2><p>To discover problems on the code more in general we can use several introspection functions that Julia provide us (some of which we have already saw):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # @less rand(3)  # Show the source code of the specific method invoked - use `q` to quit
       # @edit rand(3)  # Like @loss but it opens the source code in an editor
       methods(foo)</code><code class="nohighlight hljs ansi" style="display:block;"># 2 methods for generic function &quot;foo&quot; from <span class="sgr33">Main.var&quot;Main&quot;</span>:
 [1] foo()
<span class="sgr90">     @</span> <span class="sgr90"><span class="sgr4">REPL[1]:1</span></span>
 [2] foo(<span class="sgr90">n</span>)
<span class="sgr90">     @</span> <span class="sgr90"><span class="sgr4">REPL[2]:1</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @which foo(2)          # which method am I using when I call foo with an integer?</code><code class="nohighlight hljs ansi" style="display:block;">foo(<span class="sgr90">n</span>)
<span class="sgr90">     @</span> <span class="sgr90">Main.var&quot;Main&quot;</span> <span class="sgr90"><span class="sgr4">REPL[2]:1</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">Matrix{Float64}<span class="sgr90"> (alias for Array{Float64, 2})</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eltype(a)</code><code class="nohighlight hljs ansi" style="display:block;">Float64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isa(1.2, Number)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(Foo)</code><code class="nohighlight hljs ansi" style="display:block;">(:x,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dump(fobj)</code><code class="nohighlight hljs ansi" style="display:block;">Main.var&quot;Main&quot;.Foo
  x: Int64 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; names(Main, all=false) # available (e.g. exported) identifiers of a given module</code><code class="nohighlight hljs ansi" style="display:block;">13-element Vector{Symbol}:
 :Base
 :Core
 :LESSONS_ROOTDIR
 :LESSONS_ROOTDIR_TMP
 :LESSONS_SUBDIR
 :MAKE_PDF
 :Main
 :include_sandbox
 :link_example
 :literate_directory
 :makeList
 :preprocess
 :rdir</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sizeof(2)              # bytes</code><code class="nohighlight hljs ansi" style="display:block;">8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemin(Int64)</code><code class="nohighlight hljs ansi" style="display:block;">-9223372036854775808</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemax(Int64)</code><code class="nohighlight hljs ansi" style="display:block;">9223372036854775807</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstring(2)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;0000000000000000000000000000000000000000000000000000000000000010&quot;</code></pre><p>Various low-level interpretation of an expression</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_native foo(3)</code><code class="nohighlight hljs ansi" style="display:block;">	.text
	.file	&quot;foo&quot;
	.globl	julia_foo_38008                 # -- Begin function julia_foo_38008
	.p2align	4, 0x90
	.type	julia_foo_38008,@function
julia_foo_38008:                        # @julia_foo_38008
; ┌ @ REPL[2]:1 within `foo`
# %bb.0:                                # %top
	push	rbp
	mov	rbp, rsp
	push	r15
	push	r14
	push	r12
	push	rbx
	sub	rsp, 32
	vxorps	xmm0, xmm0, xmm0
	vmovaps	xmmword ptr [rbp - 64], xmm0
	mov	qword ptr [rbp - 48], 0
	#APP
	mov	rax, qword ptr fs:[0]
	#NO_APP
	mov	rdx, rdi
	lea	rcx, [rbp - 64]
	movabs	rdi, 140375528943696
; │ @ REPL[2]:2 within `foo`
; │┌ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/Random.jl:279 within `rand` @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/Random.jl:291 @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/Random.jl:290
; ││┌ @ boot.jl:494 within `Array` @ boot.jl:487 @ boot.jl:479
	mov	rsi, rdx
	mov	r12, qword ptr [rax - 8]
	mov	qword ptr [rbp - 64], 4
	mov	rax, qword ptr [r12]
	mov	qword ptr [rbp - 56], rax
	movabs	rax, 140376665409696
	mov	qword ptr [r12], rcx
	call	rax
; ││└
; ││┌ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/Random.jl:269 within `rand!` @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:293
; │││┌ @ essentials.jl:10 within `length`
	mov	rbx, qword ptr [rax + 8]
; │││└
; │││┌ @ abstractarray.jl:1237 within `pointer`
; ││││┌ @ pointer.jl:65 within `unsafe_convert`
	mov	r14, qword ptr [rax]
; ││└└└
; ││┌ @ boot.jl:494 within `Array` @ boot.jl:487 @ boot.jl:479
	mov	r15, rax
; ││└
; ││┌ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/Random.jl:269 within `rand!` @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:293
; │││┌ @ int.jl:88 within `*`
	shl	rbx, 3
; │││└
; │││┌ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:141 within `xoshiro_bulk`
; ││││┌ @ operators.jl:425 within `&gt;=`
; │││││┌ @ int.jl:514 within `&lt;=`
	cmp	rbx, 64
; ││││└└
	jl	.LBB0_2
# %bb.1:                                # %L11
; ││││ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:142 within `xoshiro_bulk`
	movabs	rax, offset j_xoshiro_bulk_simd_38010
	mov	qword ptr [rbp - 48], r15
	mov	rdi, r14
	mov	rsi, rbx
	call	rax
; ││││ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:143 within `xoshiro_bulk`
; ││││┌ @ int.jl:86 within `-`
	sub	rbx, rax
; ││││└
; ││││ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:144 within `xoshiro_bulk`
; ││││┌ @ pointer.jl:282 within `+`
	add	r14, rax
.LBB0_2:                                # %L17
; ││││└
; ││││ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:146 within `xoshiro_bulk`
; ││││┌ @ operators.jl:276 within `!=`
; │││││┌ @ promotion.jl:521 within `==`
	test	rbx, rbx
; ││││└└
	je	.LBB0_4
# %bb.3:                                # %L22
; ││││ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:147 within `xoshiro_bulk`
	movabs	rax, offset j_xoshiro_bulk_nosimd_38011
	mov	qword ptr [rbp - 48], r15
	mov	rdi, r14
	mov	rsi, rbx
	call	rax
.LBB0_4:                                # %L24
; │└└└
; │ @ REPL[2]:3 within `foo`
	movabs	rax, offset &quot;j_+_38012&quot;
	mov	qword ptr [rbp - 48], r15
	mov	rdi, r15
	mov	rsi, r15
	call	rax
; │ @ REPL[2]:4 within `foo`
	movabs	rcx, offset &quot;j_*_38013&quot;
	mov	qword ptr [rbp - 48], rax
	mov	rdi, rax
	mov	rsi, rax
	call	rcx
	mov	rcx, qword ptr [rbp - 56]
	mov	qword ptr [r12], rcx
; │ @ REPL[2]:5 within `foo`
	add	rsp, 32
	pop	rbx
	pop	r12
	pop	r14
	pop	r15
	pop	rbp
	ret
.Lfunc_end0:
	.size	julia_foo_38008, .Lfunc_end0-julia_foo_38008
; └
                                        # -- End function
	.section	&quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_llvm foo(3)</code><code class="nohighlight hljs ansi" style="display:block;">;  @ REPL[2]:1 within `foo`
define nonnull {}* @julia_foo_38056(i64 signext %0) #0 {
top:
  %gcframe3 = alloca [3 x {}*], align 16
  %gcframe3.sub = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe3, i64 0, i64 0
  %1 = bitcast [3 x {}*]* %gcframe3 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %1, i8 0, i64 24, i1 true)
  %thread_ptr = call i8* asm &quot;movq %fs:0, $0&quot;, &quot;=r&quot;() #7
  %tls_ppgcstack = getelementptr i8, i8* %thread_ptr, i64 -8
  %2 = bitcast i8* %tls_ppgcstack to {}****
  %tls_pgcstack = load {}***, {}**** %2, align 8
;  @ REPL[2]:2 within `foo`
; ┌ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/Random.jl:279 within `rand` @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/Random.jl:291 @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/Random.jl:290
; │┌ @ boot.jl:494 within `Array` @ boot.jl:487 @ boot.jl:479
    %3 = bitcast [3 x {}*]* %gcframe3 to i64*
    store i64 4, i64* %3, align 16
    %4 = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe3, i64 0, i64 1
    %5 = bitcast {}** %4 to {}***
    %6 = load {}**, {}*** %tls_pgcstack, align 8
    store {}** %6, {}*** %5, align 8
    %7 = bitcast {}*** %tls_pgcstack to {}***
    store {}** %gcframe3.sub, {}*** %7, align 8
    %8 = call nonnull {}* inttoptr (i64 140376665409696 to {}* ({}*, i64, i64)*)({}* inttoptr (i64 140375528943696 to {}*), i64 %0, i64 %0)
; │└
; │┌ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/Random.jl:269 within `rand!` @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:293
; ││┌ @ abstractarray.jl:1237 within `pointer`
; │││┌ @ pointer.jl:65 within `unsafe_convert`
      %9 = bitcast {}* %8 to i8**
      %arrayptr = load i8*, i8** %9, align 8
      %10 = ptrtoint i8* %arrayptr to i64
; ││└└
; ││┌ @ essentials.jl:10 within `length`
     %11 = bitcast {}* %8 to { i8*, i64, i16, i16, i32 }*
     %arraylen_ptr = getelementptr inbounds { i8*, i64, i16, i16, i32 }, { i8*, i64, i16, i16, i32 }* %11, i64 0, i32 1
     %arraylen = load i64, i64* %arraylen_ptr, align 8
; ││└
; ││┌ @ int.jl:88 within `*`
     %12 = shl i64 %arraylen, 3
; ││└
; ││┌ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:141 within `xoshiro_bulk`
; │││┌ @ operators.jl:425 within `&gt;=`
; ││││┌ @ int.jl:514 within `&lt;=`
       %13 = icmp slt i64 %12, 64
; │││└└
     br i1 %13, label %L17, label %L11

L11:                                              ; preds = %top
     %14 = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe3, i64 0, i64 2
     store {}* %8, {}** %14, align 16
; │││ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:142 within `xoshiro_bulk`
     %15 = call i64 @j_xoshiro_bulk_simd_38058(i64 zeroext %10, i64 signext %12)
; │││ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:143 within `xoshiro_bulk`
; │││┌ @ int.jl:86 within `-`
      %16 = sub i64 %12, %15
; │││└
; │││ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:144 within `xoshiro_bulk`
; │││┌ @ pointer.jl:282 within `+`
      %17 = getelementptr i8, i8* %arrayptr, i64 %15
      %18 = ptrtoint i8* %17 to i64
; ││││┌ @ essentials.jl:522 within `oftype`
; │││││┌ @ pointer.jl:26 within `convert`
; ││││││┌ @ boot.jl:800 within `Ptr`
         br label %L17

L17:                                              ; preds = %L11, %top
         %value_phi = phi i64 [ %18, %L11 ], [ %10, %top ]
         %value_phi1 = phi i64 [ %16, %L11 ], [ %12, %top ]
; │││└└└└
; │││ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:146 within `xoshiro_bulk`
; │││┌ @ operators.jl:276 within `!=`
; ││││┌ @ promotion.jl:521 within `==`
       %.not = icmp eq i64 %value_phi1, 0
; │││└└
     br i1 %.not, label %L24, label %L22

L22:                                              ; preds = %L17
     %19 = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe3, i64 0, i64 2
     store {}* %8, {}** %19, align 16
; │││ @ /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/Random/src/XoshiroSimd.jl:147 within `xoshiro_bulk`
     call void @j_xoshiro_bulk_nosimd_38059(i64 zeroext %value_phi, i64 signext %value_phi1)
     br label %L24

L24:                                              ; preds = %L22, %L17
     %20 = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe3, i64 0, i64 2
     store {}* %8, {}** %20, align 16
; └└└
;  @ REPL[2]:3 within `foo`
  %21 = call nonnull {}* @&quot;j_+_38060&quot;({}* nonnull %8, {}* nonnull %8)
  store {}* %21, {}** %20, align 16
;  @ REPL[2]:4 within `foo`
  %22 = call nonnull {}* @&quot;j_*_38061&quot;({}* nonnull %21, {}* nonnull %21)
  %23 = load {}*, {}** %4, align 8
  %24 = bitcast {}*** %tls_pgcstack to {}**
  store {}* %23, {}** %24, align 8
;  @ REPL[2]:5 within `foo`
  ret {}* %22
}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_typed foo(3)</code><code class="nohighlight hljs ansi" style="display:block;">CodeInfo(
<span class="sgr90">1 ──</span> %1  = $(Expr(:foreigncall, :(:jl_alloc_array_2d), Matrix{Float64}, svec(Any, Int64, Int64), 0, :(:ccall), Matrix{Float64}, Core.Argument(2), Core.Argument(2), Core.Argument(2), Core.Argument(2)))<span class="sgr36">::Matrix{Float64}</span>
<span class="sgr90">│   </span> %2  = $(Expr(:gc_preserve_begin, :(%1)))
<span class="sgr90">│   </span> %3  = $(Expr(:foreigncall, :(:jl_array_ptr), Ptr{Float64}, svec(Any), 0, :(:ccall), :(%1)))<span class="sgr36">::Ptr{Float64}</span>
<span class="sgr90">│   </span> %4  = Base.bitcast(Ptr{UInt8}, %3)<span class="sgr36">::Ptr{UInt8}</span>
<span class="sgr90">│   </span> %5  = Base.arraylen(%1)<span class="sgr36">::Int64</span>
<span class="sgr90">│   </span> %6  = Base.mul_int(%5, 8)<span class="sgr36">::Int64</span>
<span class="sgr90">│   </span> %7  = Random.XoshiroSimd.Float64<span class="sgr36">::Type{Float64}</span>
<span class="sgr90">│   </span> %8  = Random.XoshiroSimd._bits2float<span class="sgr36">::typeof(Random.XoshiroSimd._bits2float)</span>
<span class="sgr90">│   </span> %9  = Base.sle_int(64, %6)<span class="sgr36">::Bool</span>
<span class="sgr90">└───</span>       goto #3 if not %9
<span class="sgr90">2 ──</span> %11 = invoke Random.XoshiroSimd.xoshiro_bulk_simd($(QuoteNode(Random.TaskLocalRNG()))::Random.TaskLocalRNG, %4::Ptr{UInt8}, %6::Int64, %7::Type{Float64}, $(QuoteNode(Val{8}()))::Val{8}, %8::typeof(Random.XoshiroSimd._bits2float))<span class="sgr36">::Int64</span>
<span class="sgr90">│   </span> %12 = Base.sub_int(%6, %11)<span class="sgr36">::Int64</span>
<span class="sgr90">│   </span> %13 = Core.bitcast(Core.UInt, %4)<span class="sgr36">::UInt64</span>
<span class="sgr90">│   </span> %14 = Base.bitcast(UInt64, %11)<span class="sgr36">::UInt64</span>
<span class="sgr90">│   </span> %15 = Base.add_ptr(%13, %14)<span class="sgr36">::UInt64</span>
<span class="sgr90">└───</span> %16 = Core.bitcast(Ptr{UInt8}, %15)<span class="sgr36">::Ptr{UInt8}</span>
<span class="sgr90">3 ┄─</span> %17 = φ (#2 =&gt; %16, #1 =&gt; %4)<span class="sgr36">::Ptr{UInt8}</span>
<span class="sgr90">│   </span> %18 = φ (#2 =&gt; %12, #1 =&gt; %6)<span class="sgr36">::Int64</span>
<span class="sgr90">│   </span> %19 = (%18 === 0)<span class="sgr36">::Bool</span>
<span class="sgr90">│   </span> %20 = Base.not_int(%19)<span class="sgr36">::Bool</span>
<span class="sgr90">└───</span>       goto #5 if not %20
<span class="sgr90">4 ──</span>       invoke Random.XoshiroSimd.xoshiro_bulk_nosimd($(QuoteNode(Random.TaskLocalRNG()))::Random.TaskLocalRNG, %17::Ptr{UInt8}, %18::Int64, %7::Type{Float64}, %8::typeof(Random.XoshiroSimd._bits2float))<span class="sgr90">::Any</span>
<span class="sgr90">5 ┄─</span>       goto #6
<span class="sgr90">6 ──</span>       $(Expr(:gc_preserve_end, :(%2)))
<span class="sgr90">└───</span>       goto #7
<span class="sgr90">7 ──</span>       goto #8
<span class="sgr90">8 ──</span>       goto #9
<span class="sgr90">9 ──</span>       goto #10
<span class="sgr90">10 ─</span>       goto #11
<span class="sgr90">11 ─</span> %30 = invoke Main.var&quot;Main&quot;.:+(%1::Matrix{Float64}, %1::Matrix{Float64})<span class="sgr36">::Matrix{Float64}</span>
<span class="sgr90">│   </span> %31 = invoke Main.var&quot;Main&quot;.:*(%30::Matrix{Float64}, %30::Matrix{Float64})<span class="sgr36">::Matrix{Float64}</span>
<span class="sgr90">└───</span>       return %31
) =&gt; Matrix{Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_lowered foo(3)</code><code class="nohighlight hljs ansi" style="display:block;">CodeInfo(
<span class="sgr90">1 ─</span>     a = Main.var&quot;Main&quot;.rand(n, n)
<span class="sgr90">│  </span>     b = a + a
<span class="sgr90">│  </span>     c = b * b
<span class="sgr90">└──</span>     return c
)</code></pre><p>We can use a debugger, like e.g. the one integrated in Juno or VSCode. Graphical debuggers allow to put a <em>breakpoint</em> on some specific line of code, run the code in debug mode (yes, it will be slower), let the program arrive to the breakpoint and inspect the state of the system at that point of the code, including local variables. In Julia we can also <em>change</em> the program interactively ! Other typycal functions are running a single line, running inside a function, running until the current function return, ecc..</p><h2 id="Runtime-exceptions"><a class="docs-heading-anchor" href="#Runtime-exceptions">Runtime exceptions</a><a id="Runtime-exceptions-1"></a><a class="docs-heading-anchor-permalink" href="#Runtime-exceptions" title="Permalink"></a></h2><p>As many (all?) languages, Julia when &quot;finds&quot; an error issues an exception, that if it is not caugth at higher level in the call stack (i.e. recognised and handled) lead to an error and return to the prompt or termination of the script (and rarely with the Julia process crashing altogether).</p><p>The idea is that we <em>try</em> some potentially dangerous code and if some error is raised in this code we <em>catch</em> it and handle it.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function customIndex(vect,idx;toReturn=0)
           try
               vect[idx]
           catch e
               if isa(e,BoundsError)
                   return toReturn
               end
               rethrow(e)
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">customIndex (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = [1,2,3]
       # a[4] # Error (&quot;BoundsError&quot; to be precise)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 1
 2
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; customIndex(a,4)</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>Note that handling exceptions is computationally expensive, so do not use exceptions in place of conditional statements</p><h2 id="parallel_computation"><a class="docs-heading-anchor" href="#parallel_computation">Parallel computation</a><a id="parallel_computation-1"></a><a class="docs-heading-anchor-permalink" href="#parallel_computation" title="Permalink"></a></h2><p>Finally one note on parallel computation. We see only some basic usage of multithreading and multiprocesses in this course, but with Julia it is relativelly easy to parallelise the code either using multiple threads or multiple processes. What&#39;s the difference ?</p><ul><li><strong>multithread</strong><ul><li>advantages: computationally &quot;cheap&quot; to create (the memory is shared)</li><li>disadvantages: limited to the number of cores within a CPU, require attention in not overwriting the same memory or doing it at the intended order (&quot;data race&quot;), we can&#39;t add threads dynamically (within a script)</li></ul></li><li><strong>multiprocesses</strong><ul><li>advantages: unlimited number, can be run in different CPUs of the same machine or differnet nodes of a cluster, even using SSH on different networks, we can add processes from within our code with <code>addprocs(nToAdd)</code></li><li>disadvantages: the memory being copied (each process will have its own memory) are computationally expensive (you need to have a gain higher than the cost on setting a new process) and require attention to select which memory a given process will need to &quot;bring with it&quot; for its functionality</li></ul></li></ul><p>Note that if you are reading this document on the github pages, this script is compiled using GitHub actions where a single thread and process are available, so you will not see performance gains.</p><h3 id="Multithreading"><a class="docs-heading-anchor" href="#Multithreading">Multithreading</a><a id="Multithreading-1"></a><a class="docs-heading-anchor-permalink" href="#Multithreading" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is not possible to add threads dinamically, either we have to start Julia with the parameter <code>-t</code> (e.g. <code>-t 8</code> or <code>-t auto</code>) in the command line or use the VSCode Julia externsion setting <code>Julia: Num Threads</code></p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function inner(x)
           s = 0.0
           for i in 1:x
               for j in 1:i
                   if j%2 == 0
                       s += j
                   else
                       s -= j
                   end
               end
           end
           return s
       end</code><code class="nohighlight hljs ansi" style="display:block;">inner (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function parentSingleThread(x,y)
           toTest = x .+ (1:y)
           out = zeros(length(toTest))
           for i in 1:length(toTest)
               out[i] = inner(toTest[i])
           end
           return out
       end</code><code class="nohighlight hljs ansi" style="display:block;">parentSingleThread (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function parentThreaded(x,y)
           toTest = x .+ (1:y)
           out = zeros(length(toTest))
           Threads.@threads for i in 1:length(toTest)
               out[i] = inner(toTest[i])
           end
           return out
       end</code><code class="nohighlight hljs ansi" style="display:block;">parentThreaded (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 100</code><code class="nohighlight hljs ansi" style="display:block;">100</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = 20</code><code class="nohighlight hljs ansi" style="display:block;">20</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; str = parentSingleThread(x,y)</code><code class="nohighlight hljs ansi" style="display:block;">20-element Vector{Float64}:
 -51.0
   0.0
 -52.0
   0.0
 -53.0
   0.0
 -54.0
   0.0
 -55.0
   0.0
 -56.0
   0.0
 -57.0
   0.0
 -58.0
   0.0
 -59.0
   0.0
 -60.0
   0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mtr = parentThreaded(x,y)</code><code class="nohighlight hljs ansi" style="display:block;">20-element Vector{Float64}:
 -51.0
   0.0
 -52.0
   0.0
 -53.0
   0.0
 -54.0
   0.0
 -55.0
   0.0
 -56.0
   0.0
 -57.0
   0.0
 -58.0
   0.0
 -59.0
   0.0
 -60.0
   0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; str == mtr # true</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Threads.nthreads() # 4 in my case</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Threads.threadid()</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime parentSingleThread(100,20) # 140 μs on my machine</code><code class="nohighlight hljs ansi" style="display:block;">  114.285 μs (1 allocation: 224 bytes)
20-element Vector{Float64}:
 -51.0
   0.0
 -52.0
   0.0
 -53.0
   0.0
 -54.0
   0.0
 -55.0
   0.0
 -56.0
   0.0
 -57.0
   0.0
 -58.0
   0.0
 -59.0
   0.0
 -60.0
   0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime parentThreaded(100,20)     #  47 μs</code><code class="nohighlight hljs ansi" style="display:block;">  41.178 μs (22 allocations: 2.42 KiB)
20-element Vector{Float64}:
 -51.0
   0.0
 -52.0
   0.0
 -53.0
   0.0
 -54.0
   0.0
 -55.0
   0.0
 -56.0
   0.0
 -57.0
   0.0
 -58.0
   0.0
 -59.0
   0.0
 -60.0
   0.0</code></pre><h3 id="Multiprocessing"><a class="docs-heading-anchor" href="#Multiprocessing">Multiprocessing</a><a id="Multiprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Multiprocessing" title="Permalink"></a></h3><p><em><strong>NOTE</strong></em> <em>The code on multiprocessing is commented out (not executed, so you don&#39;t see the output) as GitHub actions (that are used to run this code and render the web pages you are reading) have problems running multi-process functions:</em></p><pre><code class="language-julia hljs">using Distributed     # from the Standard Library
addprocs(3)           # 2,3,4</code></pre><p>The first process is considered a sort of &quot;master&quot; process, the other one are the &quot;workers&quot; We can add processes on other machines by providing the SSH connection details directly in the <code>addprocs()</code> call (Julia must be installed on that machines as well) We can alternativly start Julia directly with <em>n</em> worker processes using the armument <code>-p n</code> in the command line.</p><pre><code class="language-julia hljs">println(&quot;Worker pids: &quot;)
for pid in workers()  # return a vector to the pids
    println(pid)      # 2,3,4
end
rmprocs(workers()[1])    #  remove process pid 2
println(&quot;Worker pids: &quot;)
for pid in workers()
    println(pid) # 3,4 are left
end
@everywhere begin using Distributed end # this is needed only in GitHub action
@everywhere println(myid()) # 4,3</code></pre><h4 id="Run-heavy-tasks-in-parallel"><a class="docs-heading-anchor" href="#Run-heavy-tasks-in-parallel">Run heavy tasks in parallel</a><a id="Run-heavy-tasks-in-parallel-1"></a><a class="docs-heading-anchor-permalink" href="#Run-heavy-tasks-in-parallel" title="Permalink"></a></h4><pre><code class="language-julia hljs">using Distributed, BenchmarkTools
a = rand(1:35,100)
@everywhere function fib(n)
    if n == 0 return 0 end
    if n == 1 return 1 end
    return fib(n-1) + fib(n-2)
end</code></pre><p>The macro <code>@everywhere</code> make available the given function (or functions with <code>@everywhere begin [shared function definitions] end</code> or <code>@everywhere include(&quot;sharedCode.jl&quot;)</code>) to all the current workers.</p><pre><code class="language-julia hljs">result  = map(fib,a)</code></pre><p>The pmap function (&quot;parallel&quot; map) automatically pick up the free processes, assign them the job prom the &quot;input&quot; array and merge the results in the returned array. Note that the order is preserved:</p><pre><code class="language-julia hljs">result2 = pmap(fib,a)
result == result2
@btime map(fib,$a)  # serialised:   median time: 514 ms    1 allocations
@btime pmap(fib,$a) # parallelised: median time: 265 ms 4220 allocations # the memory of `a` need to be copied to all processes</code></pre><h4 id="Divide-and-Conquer"><a class="docs-heading-anchor" href="#Divide-and-Conquer">Divide and Conquer</a><a id="Divide-and-Conquer-1"></a><a class="docs-heading-anchor-permalink" href="#Divide-and-Conquer" title="Permalink"></a></h4><p>Rather than having a &quot;heavy operation&quot; and being interested in the individual results, here we have a &quot;light&quot; operation and we want to aggregate the results of the various computations using some aggreagation function. We can then use <code>@distributed (aggregationfunction) for [forConditions]</code> macro:</p><pre><code class="language-julia hljs">using Distributed, BenchmarkTools
function f(n)   # our single-process benchmark
  s = 0.0
  for i = 1:n
    s += i/2
  end
    return s
end
function pf(n)
  s = @distributed (+) for i = 1:n # aggregate using sum on variable s
        i/2                        # the last element of the for cycle is used by the aggregator
  end
  return s
end
@btime  f(10000000) # median time: 11.1 ms   0 allocations
@btime pf(10000000) # median time:  5.7 ms 145 allocations</code></pre><p>Note that also in this case the improvement is less than proportional with the number of processes we add</p><p>Details on parallel comutation can be found <a href="https://docs.julialang.org/en/v1/manual/parallel-computing/">on the official documentation</a>, including information to run nativelly Julia on GPUs or TPUs.</p><p><a href="0106_-_Further_topics.jl">View this file on Github</a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><hr/><div id="pd_rating_holder_8962705"></div>
<script type="text/javascript">
const pageURL = window.location.href;
PDRTJS_settings_8962705 = {
"id" : "8962705",
"unique_id" : "/home/runner/work/SPMLJ/SPMLJ/lessonsSources/01_-_JULIA1_-_Basic_Julia_programming/0106_-_Further_topics.md",
"title" : "0106_-_Further_topics.md",
"permalink" : pageURL
};
</script><div class="addthis_inline_share_toolbox"></div><hr/><script src="https://utteranc.es/client.js"
        repo="sylvaticus/SPMLJ"
        issue-term="title"
        label="💬 website_comment"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script><script type="text/javascript" charset="utf-8" src="https://polldaddy.com/js/rating/rating.js"></script><!-- Go to www.addthis.com/dashboard to customize your tools -->
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-6256c971c4f745bc"></script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="0105x_EXERCISE-1.1.html">« 0105x EXERCISE-1.1</a><a class="docs-footer-nextpage" href="0106q_-_QUIZ_1.11.html">0106q - QUIZ 1.11 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Sunday 22 September 2024 16:41">Sunday 22 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
